# Setup

Create rails app from the command line 

```
$ rails new devise-jwt -T -d postgresql --api

```

Add "devise", "devise-jwt", "rack-cors" to gemfile and run bundle install
```
gem 'devise'
gem 'devise-jwt'
gem 'rack-cors'
```

The file "config/initializer/cors.rb is generated by default when using the "--api" during app. Otherwise, you will need to create it. Update this file to allow all origins to make request (for testing purposes.)

```
Rails.application.config.middleware.insert_before 0, Rack::Cors do
  allow do
    origins '*'

    resource '*',
      headers: :any,
      methods: [:get, :post, :put, :patch, :delete, :options, :head]
  end
end
```

# Setup Devise
```
$ rails g devise:install
```
Then create a model and migration with devise and migrate to generate tables
```
$ rails g devise User 
$ rails db:create db:migrate
```

Now create a model and migration with devise, and then migrate to generate tables
```
$ rails g devise User
$ rails db:create db:migrate
```

Update the generated User model with the following code.
```
class User < ApplicationRecord
  devise :database_authenticatable,
         :jwt_authenticatable,
         :registerable,
         jwt_revocation_strategy: JwtDenylist
end
```

Create another model file called "jwt_denylist.rb" and paste in the following
```
class JwtDenylist < ApplicationRecord
  include Devise::JWT::RevocationStrategies::Denylist

  self.table_name = 'jwt_denylist'
end
```
This module was previously called "Devise::JWT::RevocationStrategies::Blacklist" in case if you found anything in the older version.

Create a migration 
```
$ rails g migration CreateJwtDenylist
```
and update the migration file with
```
class CreateJwtDenylist < ActiveRecord::Migration[6.1]
  def change
    create_table :jwt_denylist do |t|
      t.string :jti, null: false
      t.datetime :exp, null: false
    end
    add_index :jwt_denylist, :jti
  end
end
```
followed by a "db:migrate". This should set up a table that tracks JWT tokens that have been logged out and should no longer have access to the app.

# Controllers
Create a sessions controller at "/controllers/users/sessions_controller.rb". We want to override the default devise sessions controller so we can specify a custom response on login and logout.

```
class Users::SessionsController < Devise::SessionsController
  respond_to :json

  private

  def respond_with(resource, _opts = {})
    render json: { message: 'You are logged in.' }, status: :ok
  end

  def respond_to_on_destroy
    log_out_success && return if current_user

    log_out_failure
  end

  def log_out_success
    render json: { message: "You are logged out." }, status: :ok
  end

  def log_out_failure
    render json: { message: "Hmm nothing happened."}, status: :unauthorized
  end
end
```

Create a new registration controller, "controllers/users/registrations_controller.rb".
```
class Users::RegistrationsController < Devise::RegistrationsController
  respond_to :json

  private

  def respond_with(resource, _opts = {})
    register_success && return if resource.persisted?

    register_failed
  end

  def register_success
    render json: { message: 'Signed up sucessfully.' }
  end

  def register_failed
    render json: { message: "Something went wrong." }
  end
end
```

Add onemore controller, "controllers/members_controller.rb", so we can test logged-in VS logged-out behavior on an endpoint that required authenticating.
```
class MembersController < ApplicationController
  before_action :authenticate_user!

  def show
    render json: { message: "If you see this, you're in!" }
  end
end
```

# More Devise Setup
Update "config/initializers/devise.rb". Add this to the file inside the config block.

```
config.jwt do |jwt|
  jwt.secret = Rails.application.credentials.devise[:jwt_secret_key]
end
``

This tells Devise-JWT to use a secret key specified in our credentials file to build tokens.

Now generate a secret key. And note the output. We'll add this into our credentials file momentarily.
```
$ rake secret
```

Rails 5.2 and above store secret keys in a way that is less intuitive, if you are used to storing secrets in "application.yml"

Open the credentials file from the command line.
```
$ EDITOR=nano rails credentials:edit
```

and paste in the following, with the key generated from running "rake secret" above.
```
devise:
  jwt_secret_key: <rake secret key>
```

# Routes 
Update your routes so they point to your new controllers, rather than to the default devise controllers.

```
Rails.application.routes.draw do
  devise_for :users,
             controllers: {
                 sessions: 'users/sessions',
                 registrations: 'users/registrations'
             }
  get '/member-data', to: 'members#show'
end
```

# Testing the app

Start your server with "rails s". Then in another terminal, we run a few curl requests.

## Access member data
First we will try to acess an authenticated controller without a JWT token.

```
$ curl -XGET -H "Content-Type: application/json" http://localhost:3000/member-data
```
which will failed since we are not loged in. However, this should work once we get our JWT token.

## Register an account
```
$ curl -XPOST -H "Content-Type: application/json" -d '{ "user": { "email": "test@example.com", "password": "12345678" } }' http://localhost:3000/users
```

### Response
```
=> {"message":"Signed up sucessfully."}
```

## Login with registered account
Now login with the account we just created.

```
$ curl -XPOST -i -H "Content-Type: application/json" -d '{ "user": { "email": "test@example.com", "password": "12345678" } }' http://localhost:3000/users/sign_in
```
The "-i" flag here is very important as it prints the response headers, which contain the JWT token for authorizing future requests.

You'll get a header in the response(see below) because you used the -i flag in your request.

## Response
```
HTTP/1.1 200 OK
X-Frame-Options: SAMEORIGIN
X-XSS-Protection: 1; mode=block
X-Content-Type-Options: nosniff
X-Download-Options: noopen
X-Permitted-Cross-Domain-Policies: none
Referrer-Policy: strict-origin-when-cross-origin
Content-Type: application/json; charset=utf-8
Vary: Accept, Origin
Authorization: Bearer eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiIxIiwic2NwIjoidXNlciIsImF1ZCI6bnVsbCwiaWF0IjoxNjIwNDkzOTUzLCJleHAiOjE2MjA0OTc1NTMsImp0aSI6IjlmZjkzMDA2LTAxNTMtNDc5YS1hYjY2LTZiMDBhOWU2NjM1ZCJ9.K6oHIUI0AuZ4HfDV1iElFe9OZoMh_st3l1rfhD0PIqY
ETag: W/"4f46b654dd4b5ef6187f2663ef5a55c4"
Cache-Control: max-age=0, private, must-revalidate
X-Request-Id: 498ef50b-4bbb-44b6-9b39-dd45d03aa7b4
X-Runtime: 0.293374
Transfer-Encoding: chunked

{"message":"You are logged in."}
```

## Access member data with JWT token 
Let's try making another request to the member endpoint, but this time using the auth token returned in the last response header.

```
$ curl -XGET -H "Authorization: Bearer eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiIxIiwic2NwIjoidXNlciIsImF1ZCI6bnVsbCwiaWF0IjoxNjIwNDkzOTUzLCJleHAiOjE2MjA0OTc1NTMsImp0aSI6IjlmZjkzMDA2LTAxNTMtNDc5YS1hYjY2LTZiMDBhOWU2NjM1ZCJ9.K6oHIUI0AuZ4HfDV1iElFe9OZoMh_st3l1rfhD0PIqY" -H "Content-Type: application/json" http://localhost:3000/member-data
```
Note that this is a sample, do remember to use your own auth token.
You should receive a sucessful response.
```
=> {"message":"If you see this, you're in!"}
```
## Sign out
You will eventually want a way for users t log out of your platform.

Making a request to "/users/sign_out" will add a token to the denylist table we created above. Subsequent requests with this token will now be invalid. The user wil need to sign in again to get a ne token in order to hit the members endpoint.

```
$ curl -XDELETE -H "Authorization: Bearer eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiIzIiwic2NwIjoidXNlciIsImF1ZCI6bnVsbCwiaWF0IjoxNjIwNDk2NTE3LCJleHAiOjE2MjA1MDAxMTcsImp0aSI6IjAyMjY4NTQzLTg0M2YtNGI1Zi1iMTBkLTgwYmU4NzYxOWI2ZCJ9.3sp3LWO1UB-qPBj2YQjPnTt4GFyyuc6UptmLpFkrvL4" -H "Content-Type: application/json" http://localhost:3000/users/sign_out
```

the response should be the following.
```
=> {"message":"You are logged out."}
```